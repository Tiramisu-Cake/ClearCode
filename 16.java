1)  1. Информативный комментарий

    int number = 564573;
    int firstSum = 0, secondSum = 0;
    
    // Если считать цифры числа N справа налево, то
    //j-ю цифру числа N можно найти по формуле:
    // k = ( N % (10^j) ) / (10^(j-1)) 
    // (здесь ^ - возведение в степень)
    // (эта формула учитывает особенности операции деления в типе int)
    //поскольку возводить в степень мы не умеем, шагом цикла будет умножение на 10
    
    if( number > 99999 && number < 1000000)
    {
      for( i = 10; i <= 1000000; i *= 10)
      {
        if( i <= 1000 )
          firstSum += (N % i) / (i / 10);
        else 
          secondSum += (N % i) / (i / 10);
      }
      if( firstSum == secondSum )  
        System.out.println("Билет счастливый, приятного аппетита!");
      else
        System.out.println("Билет не счастливый!");
    }
    else 
      System.out.println("Некорректный номер билета!");
  
2)  6. Коментарии TODO

import java.util.Scanner;
public class Main
{
  public static void main(String[] args)
  {
    Scanner keyboard = new Scanner(System.in);
    
    int N = keyboard.nextInt(); // Кол-во оценок
    int i;
    int n2 = 0; //счетчик двоек
    int n3 = 0; //счетчик троек
    int n4 = 0; //счетчик четверок
    int n5 = 0; //счетчик пятерок
    int mark = 0; //переменная для ввода оценки
    
    // TODO - нужно прояснить ТЗ. На данный момент, из условий задачи следует, что, вообще говоря, оценка в зашифрованно виде
    // может иметь более одной интерпретации. Например, число 26 может быть и двойкой,
    // и четверкой. Чтобы расшифровка была однозначной, будет ее проводить в том же порядке,
    // в котором она изложена в условии - сначала проверяем на 4, потом на 5 и т.д.
    
    // Если же одно число может обозначать несколько оценок, то достаточно в цикле стереть
    // все else.
	
    for(i = 1; i <= N; i++) 
    {
        mark = keyboard.nextInt(); // Очередная оценка
        if(mark % 2 == 0) 
            n4++;
        else 
            if (mark % 5 == 0) 
                n5++;
            else 
                if (mark % 3 == 0)
                    n3++;
                else 
                    if (mark % 13 == 0)
                    n2++;
    }

    System.out.println("Количество двоек: " + n2);
    System.out.println("Количество троек: " + n3);
    System.out.println("Количество четверок: " + n4);
    System.out.println("Количество пятерок: " + n5);
  }
}

3)  6. Коментарии TODO

    int i, j;
    // TODO - нужно определиться, какой код лушче
	
    // Есть два хороших варианта вывода узора:
    // либо выводить звездочку и пробел сразу, либо по отдельности.
    // Первый вариант имеет более понятный код - меньше условий, проще цикл
    // Второй вариант, возможно, более корректный 
    // (не выводит лишний "невидимый" пробел после последней звездочки
    // в каждой строке)
    
    // Первый вариант
  
    for( i = 1; i <= 9; i++ ) {
      for( j = 1; j <= i ; j++) {
        if( j > 10 - i ) break; 
        System.out.print("* "); 
      }
      System.out.println("");
    }
    
    // Второй вариант нравится мне меньше
   
    for( i = 1; i <= 9; i++ ) {
      for( j = 1; j <= 2 * i - 1 ; j++) {
        if( j % 2 != 0) 
          System.out.print("*");
        else
          System.out.print(" ");
        if( j > 2 * (10 - i) - 1 ) break;  
      }
      System.out.println("");
    }
    



	// Есть еще третий вариант - самый наглядный, но самый громоздкий. Нравится мне меньше всего.


    for( i = 1; i <= 5; i++ ) {
      for( j = 1; j <= 2 * i - 1 ; j++)
        if( j % 2 == 0)
          System.out.print(" ");
        else
          System.out.print("*");
      System.out.println("");
    }
    for( i = 4; i >= 1; i-- ) {
      for( j = 1; j <= 2 * i - 1; j++)
        if( j % 2 == 0)
          System.out.print(" ");
        else
          System.out.print("*");
      System.out.println("");
    }

4)  2. Представление намерений


import java.util.Random;
public class YourClassNameHere {
  public static void main(String[] args) {
    Random rand = new Random();
      
      /* 
      
      Искать совпадения будем в смысле операции пересечения теории множеств
      Например, число 1 в первом массиве присутствует два раза,
      а во втором три. Мы считаем это как одно совпадение, а не два или три.
      Если такой случай нужно посчитать как два совпадения, то
      основной код несколько упрощается:
     
      int k = 0; //счетчик совпадений
      for(int i = 0; i < n; i ++)
        for(int j = 0; j < n; j ++)
          if(list1[i] == list2_copy[j]) {
            list2_copy[j] = -1;
            k++;
            break;
          }
          
      */
     
      int n = 10; // размер массива
      int [] list1 = new int[n];
      int [] list2 = new int[n];
      // формируем массивы
      for(int i = 0; i < n; i ++)
          list1[i] = rand.nextInt(10)+1;
      for(int i = 0; i < n; i ++)
          list2[i] = rand.nextInt(10)+1;
      
      int list2_copy [] = new int[n]; //копия второго массива
      for(int i = 0; i < n; i++)
          list2_copy[i] = list2[i];
      
      /*
      Копия второго массива будет служит для отмечания тех индексов,
      у которых есть такой же элемент в первом массиве. 
      Если число совпало один раз, то мы присваем ему значение -1.
      Если число встретилось более одного раза, то присваиваем ноль,
      чтобы они лишний раз не посчитались.
      На вывод подаем те индексы, которые в копии равны -1.
     
      */
      
      //основной код
      int k = 0; //счетчик совпадений
      for(int i = 0; i < n; i ++)
        for(int j = 0; j < n; j ++)
          if(list1[i] == list2_copy[j]) {
            list2_copy[j] = -1; 
            k++;
            for(int s = j + 1; s < n; s++)
              if(list2[j] == list2_copy[s])
                list2_copy[s] = 0;
            break;
          }
      //конец основного кода
     
      //Вывод
      if(k == 0)
        System.out.println("Совпадений нет");
      else
        for(int i = 0; i < n; i ++)
          if(list2_copy[i] == -1)
            System.out.println(list2[i]);
   }
}

5) 2. Представление намерений

import java.util.Random;
public class YourClassNameHere {
  public static void main(String[] args) {
    Random rand = new Random();
      
	  // Формируем массив
      int n = 10;
      int [] list = new int[n];
      for(int i = 0; i < n; i ++)
          list[i] = rand.nextInt(500)+1; 
      
      /* 
		Метод сортировки:
        На каждом шаге мы строим цепочку - берем i-е число и ищем ближайшее
        меньшее j-е. Идем дальше по массиву, уже в поисках ближайшего
        меньшего для j-го. И т.д. Индекс каждой находки записываем во 
        вспомогательный массив. Получаем строго возрастающую цепочку чисел.
        Далее записываем эту цепочку в обратном порядке, не трогая
        остальные числа. И так на каждом шаге.
      */
      
      int x = 0, i2 = 0; //вспомогательные переменные
      int k = 1; //счетчик для вспомогательного массива    
      for(int i = 0; i < n ; i ++) {
         int [] ind = new int[n]; //вспомогательный массив
         ind[0] = i; //первый (то бишь нулевой) индекс в цепочке
         i2 = i; //запоминаем на каком мы шаге
         for(int j = i + 1; j < n; j ++)
            if(list[i] > list[j]) { //нашли число меньше
                ind[k] = j; //запомнили его индекс
                k++;
                i = j; //строим цепочку дальше
            }
         if(ind[1] != 0) { //проверяем, есть ли цепочка
            for(int j = 0; j < k / 2; j ++) { //записываем ее в обратном порядке
                x = list[ind[j]];
                list[ind[j]] = list[ind[k-1-j]];
                list[ind[k-1-j]] = x;
            }
            k = 1; //обнуляем счетчик вспомогательного массива
            i = i2; //вспоминаем на каком мы шаге
         }
      }       
  }
}

6)  2. Представление намерений

      /*
      
      Под словом будем понимать последовательность любых символов,
      кроме символа пробела ' '. Саму строку будет считать хорошей
	  в том смысле, что все слова разделены ровно одним пробелом.
	  При таком определении достаточно подсчитать количество одиночных пробелов 
      (т.е. пробелов, у которых соседние символы не пробелы) 
      и увелить результат на 1. Это и будет искомым значением.
      
      */
      
      String s = "В этой строке очень много слов.";
      char [] c = s.toCharArray();
      int n = 0;
   
      for(int i = 1; i < c.length - 1; i++)
        if(c[i-1] != ' ' && c[i] == ' ' && c[i+1] != ' ') {
          n++;
          i++; /* здесь мы уже знаем, что следующий символ
          не является пробелом, поэтому его можно не проверять */
        }
      
      if(n != 0)
        n++;
      System.out.println("Количество слов в строке: " + n);

7)  3. Прояснение

	static boolean sublineFinder(String line1, String line2) {

        int l2Len = line2.length();

		// пустая подстрока есть в любой строке
        if(l2Len == 0) {
            return true;
        }

        int l1Len = line1.length();
        int sublinesNum = l1Len - l2Len + 1; // количество возможных подстрок
		...
	}
	
8)  1. Информативные комментарии

		//переводим голоса в проценты
        double[] VotesPerc = new double[N];
        for (int i = 0; i < N; i++) {
            double a = (Votes[i] / (total * 1.0) ) * 100;
            String s = String.format("%.3f",a);
            VotesPerc[i] += Double.parseDouble(s.replace(",","."));
        }
		
9)  3. Прояснение	

		String p = "" + command.charAt(0);
        // Если первый символ не число, то вернем пустую строку.
		try {
            Integer.parseInt(p);
        }
        catch (Exception e) {
            return "";
        }
        int x = Integer.parseInt(p);
		
10) 1. Информативные комментарии

		Часть кода из метода, поворачивающего матрицу
			...
            // Углы
            for (int i = 0; i < min / 2; i++) {
                Mat[i][i] = Mat_c[i + 1][i];
                Mat[i][N - i - 1] = Mat_c[i][N - i - 2];
                Mat[M - i - 1][i] = Mat_c[M - i - 1][i + 1];
                Mat[M - i - 1][N - i - 1] = Mat_c[M - i - 2][N - i - 1];
            }

            // Строки
            for (int i = 0; i < min / 2; i++) {
                for (int j = i + 1; j < N - i - 1; j++) {
                    Mat[i][j] = Mat_c[i][j - 1];
                    Mat[M - i - 1][N - j - 1] = Mat_c[M - i - 1][N - j];
                }
            }

            // Столбцы
            for (int i = 0; i < min / 2; i++) {
                for (int j = i + 1; j < M - i - 1; j++) {
                    Mat[j][i] = Mat_c[j + 1][i];
                    Mat[M - j - 1][N - i - 1] = Mat_c[M - j - 2][N - i - 1];
                }
            }
			...