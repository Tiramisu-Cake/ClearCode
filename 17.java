1)  7-8 - Избыточный комментарий и слишком много информации.

    int number = 564573;
    int firstSum = 0, secondSum = 0;
    
	Было:
    // Если считать цифры числа N справа налево, то
    //j-ю цифру числа N можно найти по формуле:
    // k = ( N % (10^j) ) / (10^(j-1)) 
    // (здесь ^ - возведение в степень)
    // (эта формула учитывает особенности операции деления в типе int)
    //поскольку возводить в степень мы не умеем, шагом цикла будет умножение на 10
	
	Стало:
    // j-ю цифру (справа налево) цифру числа N можно найти по формуле:
    // k = ( N % (10^j) ) / (10^(j-1)) 
    
    if( number > 99999 && number < 1000000)
    {
      for( i = 10; i <= 1000000; i *= 10)
      {
        if( i <= 1000 )
          firstSum += (N % i) / (i / 10);
        else 
          secondSum += (N % i) / (i / 10);
      }
      if( firstSum == secondSum )  
        System.out.println("Билет счастливый, приятного аппетита!");
      else
        System.out.println("Билет не счастливый!");
    }
    else 
      System.out.println("Некорректный номер билета!");
  
2)  (почти) Закомментированный код

	БЫЛО:

    int i, j;
    // TODO - нужно определиться, какой код лушче
	
    // Есть два хороших варианта вывода узора:
    // либо выводить звездочку и пробел сразу, либо по отдельности.
    // Первый вариант имеет более понятный код - меньше условий, проще цикл
    // Второй вариант, возможно, более корректный 
    // (не выводит лишний "невидимый" пробел после последней звездочки
    // в каждой строке)
    
    // Первый вариант
  
    for( i = 1; i <= 9; i++ ) {
      for( j = 1; j <= i ; j++) {
        if( j > 10 - i ) break; 
        System.out.print("* "); 
      }
      System.out.println("");
    }
    
    // Второй вариант нравится мне меньше
   
    for( i = 1; i <= 9; i++ ) {
      for( j = 1; j <= 2 * i - 1 ; j++) {
        if( j % 2 != 0) 
          System.out.print("*");
        else
          System.out.print(" ");
        if( j > 2 * (10 - i) - 1 ) break;  
      }
      System.out.println("");
    }
    



	// Есть еще третий вариант - самый наглядный, но самый громоздкий. Нравится мне меньше всего.


    for( i = 1; i <= 5; i++ ) {
      for( j = 1; j <= 2 * i - 1 ; j++)
        if( j % 2 == 0)
          System.out.print(" ");
        else
          System.out.print("*");
      System.out.println("");
    }
    for( i = 4; i >= 1; i-- ) {
      for( j = 1; j <= 2 * i - 1; j++)
        if( j % 2 == 0)
          System.out.print(" ");
        else
          System.out.print("*");
      System.out.println("");
    }
	
	
	СТАЛО: Убираем альтернативные версии кода и принимает на себя ответственность за выбор лучшего варианта.
	
	 for( i = 1; i <= 9; i++ ) {
      for( j = 1; j <= i ; j++) {
        if( j > 10 - i ) break; 
        System.out.print("* "); 
      }
      System.out.println("");
    }
	
3)  Закомментированный код и избыточные комментарии

	БЫЛО:
	
import java.util.Random;
public class YourClassNameHere {
  public static void main(String[] args) {
    Random rand = new Random();
      
      /* 
      
      Искать совпадения будем в смысле операции пересечения теории множеств
      Например, число 1 в первом массиве присутствует два раза,
      а во втором три. Мы считаем это как одно совпадение, а не два или три.
      Если такой случай нужно посчитать как два совпадения, то
      основной код несколько упрощается:
     
      int k = 0; //счетчик совпадений
      for(int i = 0; i < n; i ++)
        for(int j = 0; j < n; j ++)
          if(list1[i] == list2_copy[j]) {
            list2_copy[j] = -1;
            k++;
            break;
          }
          
      */
     
      int n = 10; // размер массива
      int [] list1 = new int[n];
      int [] list2 = new int[n];
      // формируем массивы
      for(int i = 0; i < n; i ++)
          list1[i] = rand.nextInt(10)+1;
      for(int i = 0; i < n; i ++)
          list2[i] = rand.nextInt(10)+1;
      
      int list2_copy [] = new int[n]; //копия второго массива
      for(int i = 0; i < n; i++)
          list2_copy[i] = list2[i];
      
      /*
      Копия второго массива будет служит для отмечания тех индексов,
      у которых есть такой же элемент в первом массиве. 
      Если число совпало один раз, то мы присваем ему значение -1.
      Если число встретилось более одного раза, то присваиваем ноль,
      чтобы они лишний раз не посчитались.
      На вывод подаем те индексы, которые в копии равны -1.
     
      */
      
      //основной код
      int k = 0; //счетчик совпадений
      for(int i = 0; i < n; i ++)
        for(int j = 0; j < n; j ++)
          if(list1[i] == list2_copy[j]) {
            list2_copy[j] = -1; 
            k++;
            for(int s = j + 1; s < n; s++)
              if(list2[j] == list2_copy[s])
                list2_copy[s] = 0;
            break;
          }
      //конец основного кода
     
      //Вывод
      if(k == 0)
        System.out.println("Совпадений нет");
      else
        for(int i = 0; i < n; i ++)
          if(list2_copy[i] == -1)
            System.out.println(list2[i]);
   }
}

	СТАЛО:
	Убрали закомментированный код и лишние подробности
	
	import java.util.Random;
public class YourClassNameHere {
  public static void main(String[] args) {
    Random rand = new Random();
      
      /* 
      
      Искать совпадения будем в смысле операции пересечения теории множеств
      Например, число 1 в первом массиве присутствует два раза,
      а во втором три. Мы считаем это как одно совпадение, а не два или три.
          
      */
     
      int n = 10; 
      int [] list1 = new int[n];
      int [] list2 = new int[n];
 
      for(int i = 0; i < n; i ++)
          list1[i] = rand.nextInt(10)+1;
      for(int i = 0; i < n; i ++)
          list2[i] = rand.nextInt(10)+1;
      
      int list2_copy [] = new int[n]; 
      for(int i = 0; i < n; i++)
          list2_copy[i] = list2[i];
      
      /*
      Если число совпало один раз, то мы присваем ему значение -1.
      Если число встретилось более одного раза, то присваиваем ноль,
      чтобы они лишний раз не посчитались.
     
      */
      
      int k = 0; //счетчик совпадений
      for(int i = 0; i < n; i ++)
        for(int j = 0; j < n; j ++)
          if(list1[i] == list2_copy[j]) {
            list2_copy[j] = -1; 
            k++;
            for(int s = j + 1; s < n; s++)
              if(list2[j] == list2_copy[s])
                list2_copy[s] = 0;
            break;
          }

      if(k == 0)
        System.out.println("Совпадений нет");
      else
        for(int i = 0; i < n; i ++)
          if(list2_copy[i] == -1)
            System.out.println(list2[i]);
   }
}

4) Шум

	Было:
		// пустая подстрока есть в любой строке
        if(l2Len == 0) {
            return true;
        }
		
	Стало:
	    if(l2Len == 0) {
            return true;
        }

5) Шум

	Было:
		double log_Frac = 0.0;
		// находим сумму десятичных логарифмов чисел 2..N
        for(int i = 2; i <= N; i++) {
            log_Frac += Math.log10(i); 
        }
	Стало:
		double log_Frac = 0.0;
        for(int i = 2; i <= N; i++) {
            log_Frac += Math.log10(i); 
        }
6) Шум

	Было:
		int sublinesNum = l1Len - l2Len + 1; // количество возможных подстрок
	Стало:
		int sublinesNum = l1Len - l2Len + 1; 
		
7) Избыточные комментарии
	
	Было:
	if(s.length() > 0 && s.charAt(0) != ' ') // если строка не пуста и первый символ не пробел
          word_count++;
	
	Стало: убрали комментарии и упростили чтение кода
	if(s.length() > 0) {
		if(s.charAt(0) != ' ') 
          word_count++;
	}
	
8)  Избыточные комментарии

	Было:
	for(int i = 0; i < s.length() - 1; i ++) {
        if(s.charAt(i) == ' ' && s.charAt(i+1) != ' ') // если символ есть пробел, и одновременно следующий - не пробел
          word_count++;
	}
	
	Стало: убрали комментарии и упростили чтение кода
	for(int i = 0; i < s.length() - 1; i ++) {
        if(s.charAt(i) == ' ') {
			if(s.charAt(i+1) != ' ') 
				word_count++;
		}
	}
	
9)  Шум

	Было:
		String p = "" + command.charAt(0);
        // Если первый символ не число, то вернем пустую строку.
		try {
            Integer.parseInt(p);
        }
        catch (Exception e) {
            return "";
        }
        int x = Integer.parseInt(p);
		
	Стало:
		String p = "" + command.charAt(0);
		try {
            Integer.parseInt(p);
        }
        catch (Exception e) {
            return "";
        }
        int x = Integer.parseInt(p);
		
10) Шум
	
	Было:
	
import java.util.Random;
public class YourClassNameHere {
public static void main(String[] args) {
    Random rand = new Random();
      
	  // Формируем массив
      int n = 10;
      int [] list = new int[n];
      for(int i = 0; i < n; i ++)
          list[i] = rand.nextInt(500)+1; 
      
      /* 
		Метод сортировки:
        На каждом шаге мы строим цепочку - берем i-е число и ищем ближайшее
        меньшее j-е. Идем дальше по массиву, уже в поисках ближайшего
        меньшего для j-го. И т.д. Индекс каждой находки записываем во 
        вспомогательный массив. Получаем строго возрастающую цепочку чисел.
        Далее записываем эту цепочку в обратном порядке, не трогая
        остальные числа. И так на каждом шаге.
      */
      
      int x = 0, i2 = 0; //вспомогательные переменные
      int k = 1; //счетчик для вспомогательного массива    
      for(int i = 0; i < n ; i ++) {
         int [] ind = new int[n]; //вспомогательный массив
         ind[0] = i; //первый (то бишь нулевой) индекс в цепочке
         i2 = i; //запоминаем на каком мы шаге
         for(int j = i + 1; j < n; j ++)
            if(list[i] > list[j]) { //нашли число меньше
                ind[k] = j; //запомнили его индекс
                k++;
                i = j; //строим цепочку дальше
            }
         if(ind[1] != 0) { //проверяем, есть ли цепочка
            for(int j = 0; j < k / 2; j ++) { //записываем ее в обратном порядке
                x = list[ind[j]];
                list[ind[j]] = list[ind[k-1-j]];
                list[ind[k-1-j]] = x;
            }
            k = 1; //обнуляем счетчик вспомогательного массива
            i = i2; //вспоминаем на каком мы шаге
         }
      }       
  }
}

	Стало: оставили представление намерений и убрали шум, который затрудняет чтение кода
	
import java.util.Random;
public class YourClassNameHere {
  public static void main(String[] args) {
    Random rand = new Random();
      
	  // Формируем массив
      int n = 10;
      int [] list = new int[n];
      for(int i = 0; i < n; i ++)
          list[i] = rand.nextInt(500)+1; 
      
      /* 
		Метод сортировки:
        На каждом шаге мы строим цепочку - берем i-е число и ищем ближайшее
        меньшее j-е. Идем дальше по массиву, уже в поисках ближайшего
        меньшего для j-го. И т.д. Индекс каждой находки записываем во 
        вспомогательный массив. Получаем строго возрастающую цепочку чисел.
        Далее записываем эту цепочку в обратном порядке, не трогая
        остальные числа. И так на каждом шаге.
      */
      
      int x = 0, i2 = 0; 
      int k = 1;   
      for(int i = 0; i < n ; i ++) {
         int [] ind = new int[n]; 
         ind[0] = i; 
         i2 = i; 
         for(int j = i + 1; j < n; j ++)
            if(list[i] > list[j]) { 
                ind[k] = j; 
                k++;
                i = j; 
            }
         if(ind[1] != 0) { 
            for(int j = 0; j < k / 2; j ++) { 
                x = list[ind[j]];
                list[ind[j]] = list[ind[k-1-j]];
                list[ind[k-1-j]] = x;
            }
            k = 1; 
            i = i2; 
         }
      }       
  }
}

11)  Шум
	
	Было:
	
      /*
      
      Под словом будем понимать последовательность любых символов,
      кроме символа пробела ' '. Саму строку будет считать хорошей
	  в том смысле, что все слова разделены ровно одним пробелом.
	  При таком определении достаточно подсчитать количество одиночных пробелов 
      (т.е. пробелов, у которых соседние символы не пробелы) 
      и увелить результат на 1. Это и будет искомым значением.
      
      */
      
      String s = "В этой строке очень много слов.";
      char [] c = s.toCharArray();
      int n = 0;
   
      for(int i = 1; i < c.length - 1; i++)
        if(c[i-1] != ' ' && c[i] == ' ' && c[i+1] != ' ') {
          n++;
          i++; /* здесь мы уже знаем, что следующий символ
          не является пробелом, поэтому его можно не проверять */
        }
      
      if(n != 0)
        n++;
      System.out.println("Количество слов в строке: " + n);
	  
	Стало: оставили представление намерений и убрали шум, который затрудняет чтение кода
	
      /*
      
      Под словом будем понимать последовательность любых символов,
      кроме символа пробела ' '. Саму строку будет считать хорошей
	  в том смысле, что все слова разделены ровно одним пробелом.
	  При таком определении достаточно подсчитать количество одиночных пробелов 
      (т.е. пробелов, у которых соседние символы не пробелы) 
      и увелить результат на 1. Это и будет искомым значением.
      
      */
      
      String s = "В этой строке очень много слов.";
      char [] c = s.toCharArray();
      int n = 0;
   
      for(int i = 1; i < c.length - 1; i++)
        if(c[i-1] != ' ' && c[i] == ' ' && c[i+1] != ' ') {
          n++;
          i++;
        }
      
      if(n != 0)
        n++;
      System.out.println("Количество слов в строке: " + n);
	  

12)  Шум (или даем правильное название переменным вместо комментария)

	Было:

import java.util.Scanner;
public class Main
{
  public static void main(String[] args)
  {
    Scanner keyboard = new Scanner(System.in);
    
    int N = keyboard.nextInt(); // Кол-во оценок
    int i;
    int n2 = 0; //счетчик двоек
    int n3 = 0; //счетчик троек
    int n4 = 0; //счетчик четверок
    int n5 = 0; //счетчик пятерок
    int mark = 0; //переменная для ввода оценки
    
    // TODO - нужно прояснить ТЗ. На данный момент, из условий задачи следует, что, вообще говоря, оценка в зашифрованно виде
    // может иметь более одной интерпретации. Например, число 26 может быть и двойкой,
    // и четверкой. Чтобы расшифровка была однозначной, будет ее проводить в том же порядке,
    // в котором она изложена в условии - сначала проверяем на 4, потом на 5 и т.д.
    
    // Если же одно число может обозначать несколько оценок, то достаточно в цикле стереть
    // все else.
	
    for(i = 1; i <= N; i++) 
    {
        mark = keyboard.nextInt(); // Очередная оценка
        if(mark % 2 == 0) 
            n4++;
        else 
            if (mark % 5 == 0) 
                n5++;
            else 
                if (mark % 3 == 0)
                    n3++;
                else 
                    if (mark % 13 == 0)
                    n2++;
    }

    System.out.println("Количество двоек: " + n2);
    System.out.println("Количество троек: " + n3);
    System.out.println("Количество четверок: " + n4);
    System.out.println("Количество пятерок: " + n5);
  }
}

	Стало:
	
import java.util.Scanner;
public class Main
{
  public static void main(String[] args)
  {
    Scanner keyboard = new Scanner(System.in);
    
    int marksNumber = keyboard.nextInt();
    int i;
    int marksTwo = 0; 
    int marksThree = 0; 
    int marksFour = 0; 
    int marksFive = 0; 
    int currentMark = 0;
    
    // TODO - нужно прояснить ТЗ. На данный момент, из условий задачи следует, что, вообще говоря, оценка в зашифрованно виде
    // может иметь более одной интерпретации. Например, число 26 может быть и двойкой,
    // и четверкой. Чтобы расшифровка была однозначной, будет ее проводить в том же порядке,
    // в котором она изложена в условии - сначала проверяем на 4, потом на 5 и т.д.
    
    // Если же одно число может обозначать несколько оценок, то достаточно в цикле стереть
    // все else.
	
	...

  }
}